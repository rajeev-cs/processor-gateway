import {
    Controller,
    Get,
    Path,
    Post,
    Query,
    Request,
    Route,
    Security,
    SuccessResponse,
    Tags, Delete,
} from 'tsoa';
import _ from 'lodash';
import * as Boom from '@hapi/boom';
import * as express from 'express';
import { injectable, inject } from 'inversify';
import { Readable } from 'node:stream';
import { Infra } from '../interfaces/Infra.js';
import { ResponseBase } from '../interfaces/BaseTypes.js';
import {
    TaskListResponse, TaskLogsResponse,
    TaskResponse,
    TaskStatusResponse,
} from '../interfaces/TaskTypes.js';
import { parse, TaskActive, TaskCtrl } from './tasks.js';
import { Synapse } from '../synapse.js';
import { Tasks } from '../models/task.model.js';

@injectable()
@Route('/fabric/v4')
export class TaskController extends Controller {
    private taskCtl;

    constructor(
        @inject(Infra) private infra: Infra,
        @inject(Synapse) private synapse: Synapse,
    ) {
        super();
        this.taskCtl = new TaskCtrl(infra, synapse);
    }

    /**
     * List tasks in project
     * @summary List tasks in project
     */
    @Tags('Tasks')
    @Get('/projects/{projectId}/tasks')
    @Security('BearerAuth', ['read:tasks'])
    @SuccessResponse(200)
    public async listTasks(
        @Path() projectId: string,
        @Query() actionName?: string,
        @Query() activationId?: string,
        @Query() limit?: number,
        @Query() skillName?: string,
        @Query() agentName?: string,
        @Query() username?: string,
        @Query() scheduled?: boolean,
        @Query() filter?: string,
        @Query() skip?: number,
        @Query() sort?: any,
    ): Promise<TaskListResponse> {
        // eslint-disable-next-line no-undef

        // Accept legacy actionName & skillName..  filter values will overwrite these if duplicated..
        let filterQuery = {};
        try {
            filterQuery = parse(filter || {});
        } catch (e) {
            throw Boom.badRequest('Invalid "filter" value provided, it must be a valid JSON string');
        }
        const filterMerge = {
            actionName, skillName, activationId, scheduled, agentName, username, ...filterQuery,
        };
        return this.taskCtl.listTasks(projectId, {
            filter: filterMerge,
            limit,
            skip,
            sort,
        });
    }

    /**
     * Get task by taskId
     * @summary Get task by taskId
     */
    @Tags('Tasks')
    @Get('/projects/{projectId}/tasks/{taskId}')
    @Security('BearerAuth', ['read:tasks'])
    @SuccessResponse(200)
    public async getTask(
        @Path() projectId: string,
        @Path() taskId: string,
        @Query() k8s?: boolean,
    ): Promise<TaskResponse> {
        return this.taskCtl.getTask(projectId, taskId, k8s);
    }

    /**
     * Get task logs by taskId
     * @summary Get task logs by taskId
     * @param projectId
     * @param taskId - task id generated by kubernetes
     * @param raw - download log data without JSON metadata.
     * @param follow - allow to trace the log live
     * @param podName - get log by specific k8s podName
     */
    @Tags('Tasks')
    @Get('/projects/{projectId}/tasks/{taskId}/logs')
    @Security('BearerAuth', ['read:tasks'])
    @SuccessResponse(200)
    public async getTaskLogs(
        @Request() request: express.Request,
        @Path() projectId: string,
        @Path() taskId: string,
        @Query() raw?: boolean,
        @Query() follow?: boolean,
        @Query() podName?: string,
    ): Promise<Readable | TaskLogsResponse | void> {
        // TODO how to get a context with username and jwt for entire express request..
        const { jwt } = request as any;

        const { task } = await this.taskCtl.getTask(projectId, taskId);

        if ((task?.state?.toUpperCase() === TaskActive) && follow) {
            request.res.setHeader('Content-Type', 'text/event-stream');
            request.res.setHeader('Cache-Control', 'no-cache');
            request.res.setHeader('Connection', 'keep-alive');

            // Initialize SSE
            const sendSSE = (data: any) => {
                request.res.write(`data: ${data}\n\n`);
            };

            // Send initial message to client
            sendSSE(JSON.stringify('waiting for logs...\n'));

            const combinedStream = await this.taskCtl.getTaskLogs(projectId, taskId, jwt, raw, follow);

            combinedStream.on('data', (chunk) => {
                const parsedChunk = JSON.parse(chunk.toString());
                if (_.isEmpty(podName) || (!_.isEmpty(podName) && parsedChunk?.name === podName)) {
                    const logData = JSON.stringify(parsedChunk);
                    sendSSE(logData);
                }
            });

            combinedStream.on('end', () => {
                sendSSE(JSON.stringify('no more logs...\n'));
                request.res.end();
            });
            return combinedStream;
        } else {
            return this.taskCtl.getTaskLogs(projectId, taskId, jwt, raw, false, podName);
        }
    }

    /**
     * Delete task by taskId, removes kubernetes task, job, and pod from cluster
     * @summary Delete task by taskId
     * @param projectId - Project name
     * @param taskId - task id generated by kubernetes.
     */
    @Tags('Tasks')
    @Delete('/projects/{projectId}/tasks/{taskId}')
    @Security('BearerAuth', ['write:tasks'])
    @SuccessResponse(200)
    public async deleteTask(
        @Path() projectId: string,
        @Path() taskId: string,
    ): Promise<ResponseBase> {
        return this.taskCtl.deleteTask(projectId, taskId);
    }

    /**
     * Pause scheduled task by taskId, new jobs will not be scheduled until task is resumed,
     * existing jobs will continue running until completion.
     * @summary Pause scheduled task by taskId
     */
    @Tags('Tasks')
    @Post('/projects/{projectId}/tasks/{taskId}/pause')
    @Security('BearerAuth', ['execute:tasks'])
    @SuccessResponse(200)
    public async pauseSchedule(
        @Path() projectId: string,
        @Path() taskId: string,
    ): Promise<ResponseBase> {
        return this.taskCtl.pauseSchedule(projectId, taskId);
    }

    /**
     * Resume paused scheduled task by taskId, resume scheduling future jobs, missed schedules will not be scheduled.
     * @summary Pause scheduled task by taskId
     */
    @Tags('Tasks')
    @Post('/projects/{projectId}/tasks/{taskId}/resume')
    @Security('BearerAuth', ['execute:tasks'])
    @SuccessResponse(200)
    public async resumeSchedule(
        @Path() projectId: string,
        @Path() taskId: string,
    ): Promise<ResponseBase> {
        return this.taskCtl.resumeSchedule(projectId, taskId);
    }

    /**
     * get task status by task resouce name,
     * @summary Status of task by fabricResource
     */
    @Tags('Tasks')
    @Get('/projects/{projectId}/tasks/{taskResource}/status')
    @Security('BearerAuth', ['read:tasks'])
    @SuccessResponse(200)
    public async taskStatus(
        @Path() projectId: string,
        @Path() taskResource: string,
    ): Promise<TaskStatusResponse> {
        const taskQuery = {
            projectId,
            fabricResource: taskResource,
        };
        const taskRes = await Tasks.findOne(taskQuery).sort({ endtime: -1 });

        if (_.isEmpty(taskRes)) throw Boom.notFound(`"resource ${taskResource}" not found`);

        return {
            status: _.get(taskRes, ['state'], ''),
            startTime: _.get(taskRes, ['startTime'], ''),
            endTime: _.get(taskRes, ['endTime'], ''),
            resourceName: taskResource,
            resourceType: _.get(taskRes, ['resourceType'], ''),
            success: true,
        };
    }

}
